# CPU 上下文

在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）。

CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

## 如何理解

根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。


### 进程上下文切换

Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。从用户态到内核态的转变，需要通过系统调用来完成。系统调用从用户态到内核态，再从内核态到用户态都需要进行 CPU 的上下文切换。

系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。所以，系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。

每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。

什么时候进行进程上下文切换？

+ 某个进程的时间片耗尽。
+ 进程通过睡眠函数 sleep 这样的方法将自己主动挂起。
+ 有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起。
+ 发生硬件中断时，CPU 上的进程会被中断挂起。

### 线程上下文切换

内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。

什么时候进行线程上下文切换？

+ 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。
+ 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

到这里可以看出，虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。

### 中断上下文切换

为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。

对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。

## 如何查看

vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

如下使用示例：

```
[root@master ~]# vmstat 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 970240   2104 1012668    0    0    34    32  891  232  4  4 92  0  0
 5  0      0 970644   2104 1012680    0    0     0    59 2026 4440  9  9 82  0  0
 0  0      0 970164   2104 1012684    0    0     0    65 1886 4068 10  8 82  0  0
```

+ cs（context switch）是每秒上下文切换的次数。
+ in（interrupt）则是每秒中断的次数。
+ r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
+ b（Blocked）则是处于不可中断睡眠状态的进程数。

vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用 pidstat。

如下示例：

```
[root@master ~]# pidstat -w 3
Linux 3.10.0-957.1.3.el7.x86_64 (master) 	07/16/2020 	_x86_64_	(2 CPU)

11:05:38 PM   UID       PID   cswch/s nvcswch/s  Command
11:05:41 PM     0         3      7.28      0.00  ksoftirqd/0
11:05:41 PM     0         7      0.33      0.00  migration/0
11:05:41 PM     0         9     62.25      0.00  rcu_sched

```

+ cswch/s 表示每秒自愿上下文切换的次数。
+ nvcswch/s 表示每秒非自愿上下文切换的次数。

自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

中断类型切换的详细情况，从 /proc/interrupts 这个只读文件中读取。

```
[root@master ~]# cat /proc/interrupts 
            CPU0       CPU1       
   0:         78          0   IO-APIC-edge      timer
   1:         34          0   IO-APIC-edge      i8042
   8:          1          0   IO-APIC-edge      rtc0

```

## 使用经验 

如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。